/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
var pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad;
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./DynamicGroupGrid/index.ts":
/*!***********************************!*\
  !*** ./DynamicGroupGrid/index.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DynamicGroupGrid: () => (/* binding */ DynamicGroupGrid)\n/* harmony export */ });\nclass DynamicGroupGrid {\n  /**\n   * Empty constructor.\n   */\n  constructor() {\n    // runtime state for optimized updates\n    this._listenerDisposables = [];\n    this._sortColumn = null;\n    this._sortAsc = true;\n    this._colWidths = new Map();\n    this._colUniformWidth = 150;\n    this._currentPage = 1;\n    this._pageSize = DynamicGroupGrid.DEFAULT_PAGE_SIZE;\n    this._totalRecords = 0;\n    this._enablePagination = true;\n    this._lastContext = null;\n    // Empty\n  }\n  /**\n   * Used to initialize the control instance. Controls can kick off remote server calls and other initialization actions here.\n   * Data-set values are not initialized here, use updateView.\n   * @param context The entire property bag available to control via Context Object; It contains values as set up by the customizer mapped to property names defined in the manifest, as well as utility functions.\n   * @param notifyOutputChanged A callback method to alert the framework that the control has new outputs ready to be retrieved asynchronously.\n   * @param state A piece of data that persists in one session for a single user. Can be set at any point in a controls life cycle by calling 'setControlState' in the Mode interface.\n   * @param container If a control is marked control-type='standard', it will receive an empty div element within which it can render its content.\n   */\n  init(context, notifyOutputChanged, state, container) {\n    this._container = document.createElement(\"div\");\n    this._container.className = DynamicGroupGrid.CSS.ROOT;\n    container.appendChild(this._container);\n    try {\n      if (context && context.mode && typeof context.mode.trackContainerResize === 'function') {\n        try {\n          context.mode.trackContainerResize(true);\n        } catch (/* ignore */_a) {/* ignore */}\n      }\n    } catch (/* ignore */_b) {/* ignore */}\n    this._selectedGroupColumn = null;\n    this._expandedGroups = new Map();\n    this._selectedRecordId = null;\n    this._selectedRecordIds = [];\n    this._notifyOutputChanged = notifyOutputChanged;\n    this._currentPage = 1;\n    this._pageSize = DynamicGroupGrid.DEFAULT_PAGE_SIZE;\n    this._enablePagination = true;\n    this._lastContext = null;\n    // track a single window resize listener to keep collapsed header widths in sync\n    try {\n      this.addListener(window, 'resize', () => {\n        try {\n          this.adjustCollapsedHeaderWidths();\n        } catch (/* ignore */_a) {/* ignore */}\n      });\n    } catch (/* ignore */_c) {/* ignore */}\n  }\n  // Helper to register and track DOM event listeners for cleanup\n  addListener(el, evt, fn, options) {\n    // Keep a typed reference for DOM add/remove; caller can pass specific mouse/keyboard handlers\n    var listener = fn;\n    el.addEventListener(evt, listener, options);\n    this._listenerDisposables.push(() => {\n      try {\n        el.removeEventListener(evt, listener, options);\n      } catch (/* ignore */_a) {/* ignore */}\n    });\n  }\n  // Apply a consistent column width policy to both header and row cells\n  applyColumnWidth(el, columnName) {\n    try {\n      var col = columnName || '';\n      var storedW = this._colWidths.get(col);\n      var uniform = this._colUniformWidth || DynamicGroupGrid.DEFAULT_UNIFORM_WIDTH;\n      if (uniform && uniform > 0) {\n        el.style.flex = \"0 0 \".concat(uniform, \"px\");\n      } else if (storedW && storedW > 0) {\n        el.style.flex = \"0 0 \".concat(storedW, \"px\");\n      } else {\n        el.style.flex = DynamicGroupGrid.DEFAULT_FALLBACK_FLEX;\n        el.style.maxWidth = '400px';\n        el.style.minWidth = \"\".concat(DynamicGroupGrid.DEFAULT_MIN_WIDTH, \"px\");\n      }\n    } catch (e) {\n      this.handleError('applyColumnWidth', e);\n    }\n  }\n  // Centralized error handling\n  handleError(operation, error) {\n    // Log for debugging but don't expose to user\n    if (console === null || console === void 0 ? void 0 : console.error) {\n      console.error(\"DynamicGroupGrid \".concat(operation, \":\"), error);\n    }\n    // Could implement user-friendly error reporting here in the future\n  }\n  // Debug helpers removed for production build.\n  /**\n   * Called when any value in the property bag has changed. This includes field values, data-sets, global values such as container height and width, offline status, control metadata values such as label, visible, etc.\n   * @param context The entire property bag available to control via Context Object; It contains values as set up by the customizer mapped to names defined in the manifest, as well as utility functions\n   */\n  updateView(context) {\n    this._lastContext = context;\n    var dataset = context.parameters.sampleDataSet;\n    // Use dataset if available; early return if no data\n    if (!dataset || !dataset.records || Object.keys(dataset.records).length === 0) {\n      return;\n    }\n    var ds = dataset;\n    // Read pagination configuration from context\n    try {\n      if (context.parameters.pageSize && context.parameters.pageSize.raw !== null && context.parameters.pageSize.raw !== undefined) {\n        var configuredPageSize = Number(context.parameters.pageSize.raw);\n        if (configuredPageSize > 0 && configuredPageSize <= DynamicGroupGrid.MAX_PAGE_SIZE) {\n          this._pageSize = configuredPageSize;\n        }\n      }\n      if (context.parameters.enablePagination && context.parameters.enablePagination.raw !== null && context.parameters.enablePagination.raw !== undefined) {\n        this._enablePagination = Boolean(context.parameters.enablePagination.raw);\n      }\n    } catch (/* ignore */_a) {/* ignore */}\n    // read columns\n    var columns = ds.columns ? Object.values(ds.columns) : [];\n    // choose default group column: first column\n    if (!this._selectedGroupColumn && columns.length > 0) {\n      this._selectedGroupColumn = columns[0].name;\n    }\n    // show all columns; provide a slider to control uniform column width for horizontal exploration\n    var colsToShowCount = columns.length;\n    // restore persisted column widths (localStorage key based on control name)\n    try {\n      var key = 'pcf_col_widths_DynamicGroupGrid';\n      var raw = localStorage.getItem(key);\n      if (raw) {\n        var parsed = JSON.parse(raw);\n        Object.keys(parsed).forEach(k => this._colWidths.set(k, parsed[k]));\n      }\n      // load uniform width preference\n      try {\n        var uw = localStorage.getItem('dynamic_group_grid_uniform_width');\n        if (uw) this._colUniformWidth = Number(uw) || this._colUniformWidth;\n      } catch (/* ignore */_b) {/* ignore */}\n    } catch (e) {\n      void e;\n    }\n    // clear\n    this._container.innerHTML = \"\";\n    // build group-by dropdown\n    var toolbar = document.createElement(\"div\");\n    toolbar.className = DynamicGroupGrid.CSS.TOOLBAR;\n    var label = document.createElement(\"label\");\n    label.textContent = \"Group by: \";\n    toolbar.appendChild(label);\n    var select = document.createElement(\"select\");\n    select.className = \"dynamic-group-grid-select\";\n    columns.forEach(col => {\n      var opt = document.createElement(\"option\");\n      opt.value = col.name;\n      opt.text = col.displayName || col.name;\n      if (col.name === this._selectedGroupColumn) opt.selected = true;\n      select.appendChild(opt);\n    });\n    this.addListener(select, \"change\", evt => {\n      var val = evt.target.value;\n      this._selectedGroupColumn = val;\n      this._currentPage = 1; // Reset to first page when changing grouping\n      this.updateView(context);\n    });\n    toolbar.appendChild(select);\n    // Note: horizontal panning is available via native horizontal scrollbar; removed toolbar range control.\n    this._container.appendChild(toolbar);\n    // Debug toolbar removed for production build.\n    // Removed bulk action toolbar per request — native subgrid command bar will be used instead.\n    // gather records with their ids so we always use dataset ids (avoids unreliable getRecordId shapes)\n    var allEntries = ds.sortedRecordIds ? ds.sortedRecordIds.map(id => ({\n      id: String(id),\n      rec: ds.records[id]\n    })) : Object.keys(ds.records || {}).map(k => ({\n      id: String(k),\n      rec: ds.records[k]\n    }));\n    this._totalRecords = allEntries.length;\n    // Apply pagination if enabled\n    var entries = this._enablePagination ? this.getPaginatedEntries(allEntries) : allEntries;\n    var allRecordIds = entries.map(e => e.id);\n    var groups = {};\n    entries.forEach(entry => {\n      var val = this.getRecordFieldValue(entry.rec, this._selectedGroupColumn) || \"(blank)\";\n      if (!groups[val]) groups[val] = [];\n      groups[val].push(entry);\n    });\n    // render a single header that shows columns\n    var headerRow = document.createElement(\"div\");\n    headerRow.className = \"pcf-grid-header\";\n    // add selection header checkbox\n    var selectAllHeader = document.createElement('div');\n    selectAllHeader.className = 'pcf-grid-col';\n    var selectAllCb = document.createElement('input');\n    selectAllCb.type = 'checkbox';\n    selectAllCb.checked = !!(this._selectedRecordIds && this._selectedRecordIds.length > 0 && allRecordIds.length > 0 && this._selectedRecordIds.length === allRecordIds.length);\n    this.addListener(selectAllCb, 'change', evt => {\n      evt.stopPropagation();\n      if (!this._selectedRecordIds) this._selectedRecordIds = [];\n      var checked = evt.target.checked;\n      if (checked) {\n        this._selectedRecordIds = allRecordIds.slice();\n      } else {\n        this._selectedRecordIds = [];\n      }\n      this._selectedRecordId = this._selectedRecordIds.length ? this._selectedRecordIds[this._selectedRecordIds.length - 1] : null;\n      // sync selection with host dataset so native ribbon sees it (pass dataset row ids)\n      this._syncSelectionToHost(context, this._selectedRecordIds || []);\n      if (this._notifyOutputChanged) this._notifyOutputChanged();\n      // avoid full re-render; update checkboxes and classes\n      this.updateSelectionVisuals();\n    });\n    selectAllHeader.appendChild(selectAllCb);\n    headerRow.appendChild(selectAllHeader);\n    // column headers\n    var colsToShow = columns.slice(0, colsToShowCount);\n    colsToShow.forEach(c => {\n      var hc = document.createElement('div');\n      hc.className = 'pcf-grid-col';\n      // apply stored/uniform width to header cell to match row cells\n      try {\n        this.applyColumnWidth(hc, (c.name || '').toLowerCase());\n      } catch (/* ignore */_a) {/* ignore */}\n      hc.textContent = c.displayName || c.name;\n      hc.title = \"Sort by \".concat(c.displayName || c.name);\n      hc.setAttribute('data-col-name', (c.name || '').toLowerCase());\n      this.addListener(hc, 'click', evt => {\n        evt.stopPropagation();\n        if (this._sortColumn === c.name) {\n          this._sortAsc = !this._sortAsc;\n        } else {\n          this._sortColumn = c.name;\n          this._sortAsc = true;\n        }\n        this.updateView(context);\n      });\n      // sort indicator\n      if (this._sortColumn === c.name) {\n        var ind = document.createElement('span');\n        ind.className = 'pcf-sort-ind';\n        ind.textContent = this._sortAsc ? ' ▲' : ' ▼';\n        hc.appendChild(ind);\n      }\n      // add resize handle\n      var handle = document.createElement('div');\n      handle.className = 'pcf-col-handle';\n      var isDragging = false;\n      this.addListener(handle, 'mousedown', startEv => {\n        var sEv = startEv;\n        sEv.preventDefault();\n        sEv.stopPropagation();\n        isDragging = true;\n        var startX = sEv.clientX;\n        var headerCell = hc;\n        var startRect = headerCell.getBoundingClientRect();\n        var startWidth = startRect.width;\n        var colName = c.name;\n        var onMove = moveEv => {\n          if (!isDragging) return;\n          var mEv = moveEv;\n          var delta = mEv.clientX - startX;\n          var newW = Math.max(40, Math.round(startWidth + delta));\n          headerCell.style.flex = \"0 0 \".concat(newW, \"px\");\n          this._colWidths.set(colName, newW);\n          // apply to existing row cells in the DOM for visual feedback\n          try {\n            var headerIndex = Array.prototype.indexOf.call(headerRow.children, headerCell);\n            var rows = this._container.querySelectorAll('.pcf-group-row');\n            rows.forEach(rEl => {\n              var child = rEl.children[headerIndex];\n              if (child) this.applyColumnWidth(child, c.name.toLowerCase());\n            });\n          } catch (e) {\n            void e;\n          }\n        };\n        var onUp = () => {\n          isDragging = false;\n          try {\n            document.removeEventListener('mousemove', onMove);\n          } catch (/* ignore */_a) {/* ignore */}\n          try {\n            document.removeEventListener('mouseup', onUp);\n          } catch (/* ignore */_b) {/* ignore */}\n          // persist widths to localStorage\n          try {\n            var _key = 'pcf_col_widths_DynamicGroupGrid';\n            var obj = {};\n            this._colWidths.forEach((v, k) => obj[k] = v);\n            localStorage.setItem(_key, JSON.stringify(obj));\n          } catch (e) {\n            void e;\n          }\n          // final updateSelectionVisuals to ensure layout applied\n          this.updateSelectionVisuals();\n        };\n        this.addListener(document, 'mousemove', onMove);\n        this.addListener(document, 'mouseup', onUp);\n      });\n      hc.appendChild(handle);\n      headerRow.appendChild(hc);\n    });\n    // create a horizontally scrollable wrapper for header + groups so all fields can be seen\n    var gridWrapper = document.createElement('div');\n    gridWrapper.className = 'pcf-grid-scroll-wrap';\n    gridWrapper.style.overflowX = 'auto';\n    gridWrapper.style.display = 'block';\n    gridWrapper.appendChild(headerRow);\n    this._container.appendChild(gridWrapper);\n    // determine ordered list of group keys so group sections render in a predictable sort order\n    var groupKeys = Object.keys(groups || {});\n    try {\n      // sort case-insensitive and numeric-aware\n      groupKeys.sort((a, b) => {\n        var aa = a || '';\n        var bb = b || '';\n        var cmp = aa.localeCompare(bb, undefined, {\n          sensitivity: 'base',\n          numeric: true\n        });\n        // if the current sort column is the same as the group-by column, respect the sort direction\n        if (this._sortColumn === this._selectedGroupColumn) return this._sortAsc ? cmp : -cmp;\n        // otherwise default to ascending by group key\n        return cmp;\n      });\n    } catch (/* ignore sort errors and fall back to insertion order */_c) {/* ignore sort errors and fall back to insertion order */}\n    groupKeys.forEach(groupKey => {\n      var groupDiv = document.createElement(\"div\");\n      groupDiv.className = \"pcf-group-section\";\n      var header = document.createElement(\"div\");\n      header.className = \"pcf-group-header\";\n      var chev = document.createElement(\"span\");\n      chev.className = \"chev\";\n      // simple triangle using CSS border\n      chev.style.display = \"inline-block\";\n      chev.style.width = \"0\";\n      chev.style.height = \"0\";\n      chev.style.borderLeft = \"6px solid transparent\";\n      chev.style.borderRight = \"6px solid transparent\";\n      chev.style.borderTop = \"8px solid #333\";\n      // default groups to collapsed; user can click to expand\n      if (!this._expandedGroups.has(groupKey)) this._expandedGroups.set(groupKey, false);\n      if (!this._expandedGroups.get(groupKey)) chev.classList.add(\"collapsed\");\n      header.appendChild(chev);\n      var title = document.createElement(\"div\");\n      title.textContent = \"\".concat(groupKey, \" (\").concat(groups[groupKey].length, \")\");\n      header.appendChild(title);\n      this.addListener(header, 'click', () => {\n        var cur = this._expandedGroups.get(groupKey) || false;\n        this._expandedGroups.set(groupKey, !cur);\n        this.updateView(context);\n      });\n      groupDiv.appendChild(header);\n      var list = document.createElement(\"div\");\n      list.className = DynamicGroupGrid.CSS.GROUP_LIST;\n      var expanded = this._expandedGroups.get(groupKey) !== false;\n      // hide the list entirely when collapsed to avoid rendering an empty placeholder row\n      if (!expanded) {\n        list.style.display = 'none';\n        // mark parent as collapsed for CSS targeting\n        groupDiv.classList.add('collapsed');\n      }\n      if (expanded) {\n        // optionally sort group rows\n        var grpRows = groups[groupKey].slice();\n        if (this._sortColumn) {\n          var sc = this._sortColumn;\n          grpRows.sort((a, b) => {\n            var va = this.getRecordFieldValue(a.rec, sc) || '';\n            var vb = this.getRecordFieldValue(b.rec, sc) || '';\n            if (va < vb) return this._sortAsc ? -1 : 1;\n            if (va > vb) return this._sortAsc ? 1 : -1;\n            return 0;\n          });\n        }\n        grpRows.forEach(entry => {\n          var row = document.createElement(\"div\");\n          row.className = \"pcf-group-row\";\n          var recordId = entry.id;\n          var r = entry.rec;\n          if (entry.id) row.setAttribute('data-record-id', entry.id);\n          if (recordId && this._selectedRecordIds && this._selectedRecordIds.indexOf(recordId) !== -1) row.classList.add(\"selected\");\n          // add selection checkbox cell\n          var selectCell = document.createElement('div');\n          selectCell.className = 'pcf-grid-col';\n          selectCell.setAttribute('data-col-name', 'select');\n          var cb = document.createElement('input');\n          cb.type = 'checkbox';\n          cb.checked = this._selectedRecordIds && this._selectedRecordIds.indexOf(recordId) !== -1;\n          // prevent clicks on the checkbox from bubbling to the row click handler\n          this.addListener(cb, 'click', evt => {\n            evt.stopPropagation();\n          });\n          this.addListener(cb, 'change', evt => {\n            evt.stopPropagation();\n            if (!this._selectedRecordIds) this._selectedRecordIds = [];\n            var checked = evt.target.checked;\n            var idx = this._selectedRecordIds.indexOf(recordId);\n            if (checked && idx === -1) this._selectedRecordIds.push(recordId);\n            if (!checked && idx !== -1) this._selectedRecordIds.splice(idx, 1);\n            this._selectedRecordId = this._selectedRecordIds.length ? this._selectedRecordIds[this._selectedRecordIds.length - 1] : null;\n            // sync selection with host dataset\n            this._syncSelectionToHost(context, this._selectedRecordIds || []);\n            if (this._notifyOutputChanged) this._notifyOutputChanged();\n            // update visuals only\n            this.updateSelectionVisuals();\n          });\n          selectCell.appendChild(cb);\n          row.appendChild(selectCell);\n          // render a few columns values - use visible columns from dataset\n          var colsToShow = columns.slice(0, colsToShowCount);\n          colsToShow.forEach((c, idx) => {\n            var cellDiv = document.createElement('div');\n            cellDiv.className = 'pcf-grid-col';\n            // expose column name as attribute for targeted CSS\n            cellDiv.setAttribute('data-col-name', (c.name || '').toLowerCase());\n            // apply uniform/stored width via helper\n            try {\n              this.applyColumnWidth(cellDiv, (c.name || '').toLowerCase());\n            } catch (/* ignore */_a) {/* ignore */}\n            var inner = document.createElement('span');\n            inner.className = 'pcf-cell';\n            var text = this.getRecordFieldValue(r, c.name) || '';\n            if (idx === 0) {\n              var a = document.createElement('a');\n              a.href = '#';\n              a.textContent = text;\n              this.addListener(a, 'click', evt => {\n                evt.preventDefault();\n                evt.stopPropagation();\n                try {\n                  this.navigateToRecord(context, recordId);\n                } catch (_a) {\n                  this._lastRowEvent = JSON.stringify({\n                    type: 'openRequest',\n                    id: recordId\n                  });\n                  if (this._notifyOutputChanged) this._notifyOutputChanged();\n                }\n              });\n              inner.appendChild(a);\n            } else {\n              inner.textContent = text;\n            }\n            cellDiv.appendChild(inner);\n            // also set data attribute on inner for CSS selectors\n            inner.setAttribute('data-col-name', (c.name || '').toLowerCase());\n            row.appendChild(cellDiv);\n          });\n          this.addListener(row, 'click', evt => {\n            // stop group toggle\n            evt.stopPropagation();\n            // set multi-selection (Ctrl/Cmd toggle, Shift range)\n            if (!this._selectedRecordIds) this._selectedRecordIds = [];\n            if (recordId) {\n              var isCtrl = evt.ctrlKey || evt.metaKey;\n              var isShift = evt.shiftKey;\n              if (isShift && this._selectedRecordIds.length > 0) {\n                // select range from last selected to this\n                var last = this._selectedRecordIds[this._selectedRecordIds.length - 1];\n                var start = allRecordIds.indexOf(last);\n                var end = allRecordIds.indexOf(recordId);\n                if (start >= 0 && end >= 0) {\n                  var [s, e] = start <= end ? [start, end] : [end, start];\n                  var range = allRecordIds.slice(s, e + 1);\n                  this._selectedRecordIds = Array.from(new Set(this._selectedRecordIds.concat(range)));\n                }\n              } else if (isCtrl) {\n                // toggle\n                var idx = this._selectedRecordIds.indexOf(recordId);\n                if (idx === -1) this._selectedRecordIds.push(recordId);else this._selectedRecordIds.splice(idx, 1);\n              } else {\n                // single select\n                this._selectedRecordIds = [recordId];\n              }\n              // update primary single output for backward compatibility\n              this._selectedRecordId = this._selectedRecordIds.length ? this._selectedRecordIds[this._selectedRecordIds.length - 1] : null;\n              if (this._notifyOutputChanged) this._notifyOutputChanged();\n              // sync selection with host dataset\n              this._syncSelectionToHost(context, this._selectedRecordIds || []);\n              // avoid full re-render; update selection visuals\n              this.updateSelectionVisuals();\n            }\n          });\n          this.addListener(row, 'dblclick', evt => {\n            evt.stopPropagation();\n            if (recordId) {\n              try {\n                this.navigateToRecord(context, recordId);\n              } catch (_a) {\n                this._lastRowEvent = JSON.stringify({\n                  type: 'doubleClick',\n                  id: recordId\n                });\n                if (this._notifyOutputChanged) this._notifyOutputChanged();\n              }\n            }\n          });\n          list.appendChild(row);\n        });\n      }\n      groupDiv.appendChild(list);\n      gridWrapper.appendChild(groupDiv);\n    });\n    // horizontal panning is available via native scrollbar; no toolbar slider wiring necessary\n    // Add pagination controls if enabled\n    if (this._enablePagination && this._totalRecords > this._pageSize) {\n      this.renderPaginationControls();\n    }\n    // final sizing adjustment: ensure collapsed headers visually span the scrollable content\n    try {\n      this.adjustCollapsedHeaderWidths();\n    } catch (/* ignore */_d) {/* ignore */}\n  }\n  // Get paginated subset of entries\n  getPaginatedEntries(allEntries) {\n    if (!this._enablePagination || this._pageSize <= 0) {\n      return allEntries;\n    }\n    var startIndex = (this._currentPage - 1) * this._pageSize;\n    var endIndex = startIndex + this._pageSize;\n    return allEntries.slice(startIndex, endIndex);\n  }\n  // Render pagination controls\n  renderPaginationControls() {\n    if (!this._enablePagination || this._totalRecords <= this._pageSize) {\n      return;\n    }\n    var totalPages = Math.ceil(this._totalRecords / this._pageSize);\n    if (totalPages <= 1) {\n      return;\n    }\n    var paginationContainer = document.createElement('div');\n    paginationContainer.className = DynamicGroupGrid.CSS.PAGINATION_CONTAINER;\n    // Pagination info\n    var paginationInfo = document.createElement('div');\n    paginationInfo.className = DynamicGroupGrid.CSS.PAGINATION_INFO;\n    var startRecord = (this._currentPage - 1) * this._pageSize + 1;\n    var endRecord = Math.min(this._currentPage * this._pageSize, this._totalRecords);\n    paginationInfo.textContent = \"Showing \".concat(startRecord, \"-\").concat(endRecord, \" of \").concat(this._totalRecords, \" records\");\n    paginationContainer.appendChild(paginationInfo);\n    // Pagination controls\n    var paginationControls = document.createElement('div');\n    paginationControls.className = DynamicGroupGrid.CSS.PAGINATION_CONTROLS;\n    // First page button\n    var firstButton = this.createPaginationButton('<<', 1, this._currentPage === 1);\n    paginationControls.appendChild(firstButton);\n    // Previous page button\n    var prevButton = this.createPaginationButton('<', this._currentPage - 1, this._currentPage === 1);\n    paginationControls.appendChild(prevButton);\n    // Page number buttons\n    var startPage = Math.max(1, this._currentPage - 2);\n    var endPage = Math.min(totalPages, this._currentPage + 2);\n    for (var i = startPage; i <= endPage; i++) {\n      var pageButton = this.createPaginationButton(String(i), i, false, i === this._currentPage);\n      paginationControls.appendChild(pageButton);\n    }\n    // Next page button\n    var nextButton = this.createPaginationButton('>', this._currentPage + 1, this._currentPage === totalPages);\n    paginationControls.appendChild(nextButton);\n    // Last page button\n    var lastButton = this.createPaginationButton('>>', totalPages, this._currentPage === totalPages);\n    paginationControls.appendChild(lastButton);\n    paginationContainer.appendChild(paginationControls);\n    this._container.appendChild(paginationContainer);\n  }\n  // Create a pagination button\n  createPaginationButton(text, targetPage, disabled) {\n    var isActive = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    var button = document.createElement('button');\n    button.className = DynamicGroupGrid.CSS.PAGINATION_BUTTON;\n    button.textContent = text;\n    button.disabled = disabled;\n    if (isActive) {\n      button.classList.add('active');\n    }\n    if (!disabled) {\n      this.addListener(button, 'click', evt => {\n        evt.preventDefault();\n        evt.stopPropagation();\n        this.goToPage(targetPage);\n      });\n    }\n    return button;\n  }\n  // Navigate to a specific page\n  goToPage(page) {\n    if (!this._enablePagination) {\n      return;\n    }\n    var totalPages = Math.ceil(this._totalRecords / this._pageSize);\n    if (page < 1 || page > totalPages || page === this._currentPage) {\n      return;\n    }\n    this._currentPage = page;\n    // Find the context from the most recent updateView call\n    if (this._lastContext) {\n      this.updateView(this._lastContext);\n    }\n  }\n  // Ensure collapsed header background spans the scroll area width to avoid a narrow white gap\n  adjustCollapsedHeaderWidths() {\n    try {\n      var gridWrap = this._container.querySelector('.pcf-grid-scroll-wrap');\n      if (!gridWrap) return;\n      // measure the scrollable content width (including any horizontal overflow)\n      var contentWidth = gridWrap.scrollWidth || gridWrap.clientWidth || 0;\n      var headers = Array.from(this._container.querySelectorAll('.pcf-group-section.collapsed > .pcf-group-header'));\n      headers.forEach(h => {\n        // ensure header background covers the full scroll content area by setting a pseudo-full width filler via minWidth\n        // use inline style so we don't require additional CSS selectors\n        try {\n          h.style.minWidth = \"\".concat(contentWidth, \"px\");\n        } catch (/* ignore */_a) {/* ignore */}\n      });\n    } catch (/* ignore */_a) {/* ignore */}\n  }\n  /**\n   * It is called by the framework prior to a control receiving new data.\n   * @returns an object based on nomenclature defined in manifest, expecting object[s] for property marked as \"bound\" or \"output\"\n   */\n  getOutputs() {\n    return {\n      selectedRecordId: this._selectedRecordId,\n      selectedRecordIds: this._selectedRecordIds ? this._selectedRecordIds.join(',') : '',\n      rowEvent: this._lastRowEvent || ''\n    };\n  }\n  /**\n   * Called when the control is to be removed from the DOM tree. Controls should use this call for cleanup.\n   * i.e. cancelling any pending remote calls, removing listeners, etc.\n   */\n  destroy() {\n    // remove DOM and cleanup tracked listeners\n    try {\n      this._listenerDisposables.forEach(d => {\n        try {\n          d();\n        } catch (/* ignore */_a) {/* ignore */}\n      });\n    } catch (/* ignore */_a) {/* ignore */}\n    if (this._container && this._container.parentNode) {\n      this._container.parentNode.removeChild(this._container);\n    }\n  }\n  // Update only selection visuals (checkboxes and selected class) to avoid full re-render\n  updateSelectionVisuals() {\n    try {\n      var rows = this._container.querySelectorAll('.pcf-group-row');\n      rows.forEach(rEl => {\n        var row = rEl;\n        var rid = row.getAttribute('data-record-id');\n        if (!rid) return;\n        var selected = this._selectedRecordIds && this._selectedRecordIds.indexOf(rid) !== -1;\n        if (selected) row.classList.add('selected');else row.classList.remove('selected');\n        var cb = row.querySelector('input[type=\"checkbox\"]');\n        if (cb) cb.checked = !!selected;\n      });\n    } catch (/* ignore */_a) {/* ignore */}\n  }\n  // helper to safely read field value\n  getRecordFieldValue(record, fieldName) {\n    if (!fieldName) return null;\n    var value = null;\n    if (record) {\n      var recAsAny = record;\n      if (typeof recAsAny.getFormattedValue === 'function') {\n        try {\n          value = recAsAny.getFormattedValue(fieldName);\n        } catch (_a) {\n          void 0;\n        }\n      }\n      if ((value === null || value === undefined) && typeof recAsAny.getValue === \"function\") {\n        var gv = recAsAny.getValue;\n        try {\n          value = gv(fieldName);\n        } catch (_b) {\n          value = null;\n        }\n      }\n    }\n    // if getValue not available or returned undefined, try direct property access\n    if ((value === null || value === undefined) && record) {\n      var recObj = record;\n      if (recObj[fieldName] !== undefined) {\n        value = recObj[fieldName];\n      }\n    }\n    if (value === null || value === undefined) return null;\n    if (typeof value === \"object\") {\n      var vObj = value;\n      if (\"formatted\" in vObj && typeof vObj[\"formatted\"] === \"string\") return vObj[\"formatted\"];\n      if (\"name\" in vObj && typeof vObj[\"name\"] === \"string\") return vObj[\"name\"];\n      if (\"value\" in vObj && typeof vObj[\"value\"] === \"string\") return vObj[\"value\"];\n      try {\n        return JSON.stringify(vObj);\n      } catch (_c) {\n        return String(value);\n      }\n    }\n    return String(value);\n  }\n  // helper to resolve record id from various dataset shapes\n  getRecordId(record) {\n    if (!record) return null;\n    var rObj = record;\n    var maybeGet = rObj.getRecordId;\n    if (typeof maybeGet === 'function') {\n      try {\n        return maybeGet();\n      } catch (/* fallthrough */_a) {/* fallthrough */}\n    }\n    if (typeof rObj.recordId === 'string') return rObj.recordId;\n    if (typeof rObj.id === 'string') return rObj.id;\n    if (typeof rObj['$id'] === 'string') return rObj['$id'];\n    return null;\n  }\n  // helper to resolve entity logical name/type from record object\n  getRecordEntityName(record) {\n    if (!record) return null;\n    var rObj = record;\n    // try raw identifier shape first (some dataset records expose an internal _record.identifier)\n    try {\n      var raw = rObj['_record'];\n      if (raw && typeof raw === 'object') {\n        var ident = raw['identifier'];\n        if (ident && typeof ident === 'object') {\n          var entityName = ident['etn'] || ident['entityType'] || ident['entityLogicalName'];\n          if (entityName && typeof entityName === 'string') return entityName;\n        }\n      }\n    } catch (/* ignore */_a) {/* ignore */}\n    // common shapes\n    if (typeof rObj['entityType'] === 'string') return rObj['entityType'];\n    if (typeof rObj['entityLogicalName'] === 'string') return rObj['entityLogicalName'];\n    // try named reference shape\n    var maybeGetNamedRef = rObj.getNamedReference;\n    if (typeof maybeGetNamedRef === 'function') {\n      try {\n        var ref = maybeGetNamedRef();\n        if (ref && typeof ref === 'object') {\n          var rr = ref;\n          if (typeof rr['entityType'] === 'string') return rr['entityType'];\n          if (typeof rr['entityLogicalName'] === 'string') return rr['entityLogicalName'];\n        }\n      } catch (/* ignore */_b) {/* ignore */}\n    }\n    return null;\n  }\n  // helper to sync selection with host dataset safely\n  _syncSelectionToHost(context, ids) {\n    try {\n      if (!ids) ids = [];\n      var ds = context.parameters && context.parameters['sampleDataSet'];\n      if (ds) {\n        var maybeDs = ds;\n        if (typeof maybeDs.setSelectedRecordIds === 'function') {\n          try {\n            var fn = maybeDs.setSelectedRecordIds;\n            var datasetKeys = (ids || []).filter(Boolean);\n            try {\n              fn(datasetKeys);\n            } catch (/* ignore */_a) {/* ignore */}\n          } catch (/* ignore */_b) {/* ignore */}\n        }\n      }\n    } catch (/* ignore */_c) {/* ignore */}\n  }\n  // ...existing code...\n  // helper to navigate/open a record using dataset named reference or record helpers\n  navigateToRecord(context, datasetRowId) {\n    var _a, _b;\n    if (!datasetRowId) return;\n    try {\n      // navigate request\n      var ds = context.parameters && context.parameters['sampleDataSet'];\n      if (ds && ds.records && ds.records[datasetRowId]) {\n        var rec = ds.records[datasetRowId];\n        try {\n          // Prefer raw identifier shape if present (fast path for dataset records)\n          try {\n            var raw = rec['_record'];\n            if (raw && typeof raw === 'object') {\n              var ident = raw['identifier'];\n              if (ident && typeof ident === 'object') {\n                var _entityName = ident['etn'] || ident['entityType'] || ident['entityLogicalName'];\n                var idObj = ident['id'];\n                var id = idObj && (idObj['guid'] || idObj['Id'] || idObj['value']) ? String(idObj['guid'] || idObj['Id'] || idObj['value']) : undefined;\n                if (_entityName && id && context && context.navigation && typeof context.navigation.openForm === 'function') {\n                  try {\n                    // If this is the generic activitypointer, try to map to the actual activity entity using activitytypecode\n                    var finalEntity = _entityName;\n                    try {\n                      if (_entityName === 'activitypointer' && raw && raw['fields'] && typeof raw['fields'] === 'object') {\n                        var fields = raw['fields'];\n                        var activityType = fields['activitytypecode'];\n                        var atVal = activityType ? (_b = (_a = activityType['value']) !== null && _a !== void 0 ? _a : activityType['formatted']) !== null && _b !== void 0 ? _b : activityType['label'] : undefined;\n                        var at = String(atVal !== null && atVal !== void 0 ? atVal : '').toLowerCase();\n                        var map = {\n                          'phonecall': 'phonecall',\n                          'task': 'task',\n                          'email': 'email',\n                          'appointment': 'appointment',\n                          'letter': 'letter',\n                          'fax': 'fax',\n                          'serviceappointment': 'serviceappointment'\n                        };\n                        // activityType sometimes contains 'phonecall' or formatted 'Phone Call'\n                        Object.keys(map).forEach(k => {\n                          if (at.indexOf(k) !== -1) finalEntity = map[k];\n                        });\n                      }\n                    } catch (/* activity mapping failed */_c) {/* activity mapping failed */}\n                    context.navigation.openForm({\n                      entityName: finalEntity,\n                      entityId: id\n                    });\n                    return;\n                  } catch (/* ignore */_d) {/* ignore */}\n                }\n              }\n            }\n          } catch (/* raw identifier check failed */_e) {/* raw identifier check failed */}\n          // try named reference if raw not available\n          var maybeNamed = rec.getNamedReference;\n          var namedRef = typeof maybeNamed === 'function' ? maybeNamed() : null;\n          if (namedRef && typeof namedRef === 'object') {\n            // namedRef available\n            var nr = namedRef;\n            var _entityName2 = nr['entityName'] || nr['entityLogicalName'] || nr['entityType'];\n            var _id = nr['id'] || nr['entityId'] || nr['key'];\n            if (_entityName2 && _id && context && context.navigation && typeof context.navigation.openForm === 'function') {\n              try {\n                context.navigation.openForm({\n                  entityName: _entityName2,\n                  entityId: _id\n                });\n                return;\n              } catch (/* ignore */_f) {/* ignore */}\n            }\n          }\n        } catch (/* ignore */_g) {/* ignore */}\n        // fallback: try record helpers\n        var rid = this.getRecordId(rec) || datasetRowId;\n        var entityName = this.getRecordEntityName(rec) || null;\n        if (rid && entityName && context && context.navigation && typeof context.navigation.openForm === 'function') {\n          try {\n            context.navigation.openForm({\n              entityName,\n              entityId: rid\n            });\n            return;\n          } catch (/* ignore */_h) {/* ignore */}\n        }\n        // emit event fallback\n        this._lastRowEvent = JSON.stringify({\n          type: 'openRequest',\n          id: rid || datasetRowId,\n          entityName: entityName\n        });\n        if (this._notifyOutputChanged) this._notifyOutputChanged();\n      }\n    } catch (/* ignore */_j) {/* ignore */}\n  }\n  // resolve dataset entry ids to platform canonical ids (GUIDs) when possible\n  _toCanonicalIds(context, ids) {\n    var out = [];\n    try {\n      if (!ids) return out;\n      var params = context.parameters;\n      var dsRaw = params['sampleDataSet'];\n      if (!dsRaw || typeof dsRaw !== 'object') return ids.filter(Boolean);\n      var ds = dsRaw;\n      ids.forEach(id => {\n        try {\n          var rec = ds.records[id];\n          if (rec) {\n            // 1) try getRecordId()\n            var rid = this.getRecordId(rec);\n            if (rid) {\n              out.push(rid);\n              return;\n            }\n            // 2) try named reference shape\n            try {\n              var maybeNamed = rec.getNamedReference;\n              var namedRef = typeof maybeNamed === 'function' ? maybeNamed() : null;\n              if (namedRef && typeof namedRef === 'object') {\n                var nr = namedRef;\n                var idFld = nr['id'] || nr['entityId'] || nr['key'];\n                if (idFld && typeof idFld === 'object') {\n                  var idObj = idFld;\n                  var gid = idObj['guid'] || idObj['Id'] || idObj['value'];\n                  if (gid) {\n                    out.push(String(gid));\n                    return;\n                  }\n                }\n                if (typeof idFld === 'string' && idFld) {\n                  out.push(idFld);\n                  return;\n                }\n              }\n            } catch (/* ignore namedRef */_a) {/* ignore namedRef */}\n            // 3) try internal raw identifier (common in some host shapes)\n            try {\n              var raw = rec['_record'];\n              if (raw && typeof raw === 'object') {\n                var ident = raw['identifier'];\n                if (ident && typeof ident === 'object') {\n                  var _idObj = ident['id'];\n                  var _gid = _idObj && (_idObj['guid'] || _idObj['Id'] || _idObj['value']);\n                  if (_gid) {\n                    out.push(String(_gid));\n                    return;\n                  }\n                }\n                // fallback: sometimes raw has an 'id' or 'Id' directly\n                var rawAsRecord = raw;\n                if (rawAsRecord['id'] && typeof rawAsRecord['id'] === 'string') {\n                  out.push(String(rawAsRecord['id']));\n                  return;\n                }\n              }\n            } catch (/* ignore raw */_b) {/* ignore raw */}\n          }\n        } catch (/* ignore */_c) {/* ignore */}\n        if (id) out.push(id);\n      });\n    } catch (/* ignore */_a) {/* ignore */}\n    return out;\n  }\n}\n// Configurable constants and CSS class names\nDynamicGroupGrid.CSS = {\n  ROOT: 'dynamic-group-grid-root',\n  TOOLBAR: 'dynamic-group-grid-toolbar',\n  GRID_HEADER: 'pcf-grid-header',\n  GRID_COL: 'pcf-grid-col',\n  GROUP_SECTION: 'pcf-group-section',\n  GROUP_HEADER: 'pcf-group-header',\n  GROUP_LIST: 'dynamic-group-grid-list',\n  GROUP_ROW: 'pcf-group-row',\n  CELL: 'pcf-cell',\n  PAGINATION_CONTAINER: 'pcf-pagination-container',\n  PAGINATION_INFO: 'pcf-pagination-info',\n  PAGINATION_CONTROLS: 'pcf-pagination-controls',\n  PAGINATION_BUTTON: 'pcf-pagination-button'\n};\n// Configurable values (magic numbers centralized)\nDynamicGroupGrid.DEFAULT_UNIFORM_WIDTH = 150;\nDynamicGroupGrid.DEFAULT_MIN_WIDTH = 40;\nDynamicGroupGrid.DEFAULT_FALLBACK_FLEX = '1 1 120px';\nDynamicGroupGrid.DEFAULT_PAGE_SIZE = 25;\nDynamicGroupGrid.MAX_PAGE_SIZE = 100;\n\n//# sourceURL=webpack://pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad/./DynamicGroupGrid/index.ts?\n}");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./DynamicGroupGrid/index.ts"](0, __webpack_exports__, __webpack_require__);
/******/ 	pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad = __webpack_exports__;
/******/ 	
/******/ })()
;
if (window.ComponentFramework && window.ComponentFramework.registerControl) {
	ComponentFramework.registerControl('DynamicGroupGrid.PCF.DynamicGroupGrid', pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad.DynamicGroupGrid);
} else {
	var DynamicGroupGrid = DynamicGroupGrid || {};
	DynamicGroupGrid.PCF = DynamicGroupGrid.PCF || {};
	DynamicGroupGrid.PCF.DynamicGroupGrid = pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad.DynamicGroupGrid;
	pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad = undefined;
}